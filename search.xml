<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构</title>
    <url>/2020/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>数据结构 - 数据之间的关联关系</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据结构在学什么"><a href="#数据结构在学什么" class="headerlink" title="数据结构在学什么"></a>数据结构在学什么</h3><ul>
<li>如何用程序代码把现实世界的问题<strong>信息化</strong></li>
<li>如何用计算机<em>高效的</em>处理这些信息从而创造价值</li>
</ul>
<h3 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><ul>
<li>集合</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图状结构(网状结构)</li>
</ul>
<h4 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构(存储结构)"></a>物理结构(存储结构)</h4><blockquote>
<p>如何用计算机表示数据元素的逻辑关系</p>
</blockquote>
<ul>
<li><p>顺序存储</p>
<p>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</p>
</li>
<li><p>链式存储</p>
<p>逻辑上相邻的元素在物理位置上可以不相邻,而是借助元素存储地址的<strong>指针</strong>来表示元素之间的逻辑关系</p>
</li>
<li><p>索引存储</p>
<p>在存储元素信息的同时,还建立附加的索引表</p>
</li>
<li><p>散列存储</p>
<p>根据元素的关键字直接计算出该元素的存储地址,又称哈希(Hash)存储</p>
</li>
</ul>
<ol>
<li>顺序存储在物理上是连续的, 其他非顺序存储则各个元素在物理上是可以离散
的</li>
<li>存储结构会影响存储空间分配的方便程度</li>
<li>存储结构会影响数据运算的速度</li>
</ol>
<h4 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h4><p>施加在数据上的运算包括运算的定义和实现
运算的定义是针对逻辑结构的,指出运算的功能.
运算的实现是针对存储结构的,指出运算的具体操作步骤.</p>
<h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><p>问题规模为 N
只有当 N 足够大时,才会出现性能问题</p>
<p>简化时间复杂度表达式,可以只考虑阶数高的部分
大 O 表示”同阶”,同等数量级.即当 n 等于无穷时,二者之比为常数</p>
<ul>
<li>O(n)</li>
<li>O(n²)</li>
<li>O(n³)</li>
</ul>
<p>复杂度排序: 常&lt;对&lt;幂&lt;指&lt;阶</p>
<h3 id="算法的空间规模-内存需求"><a href="#算法的空间规模-内存需求" class="headerlink" title="算法的空间规模(内存需求)"></a>算法的空间规模(内存需求)</h3><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是具有<strong>相同</strong>(每个数据元素所占内存空间一样大)数据类型的 n 个数据元素的有限序列</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>用顺序存储方式实现的线性表
<img src="https://s1.ax1x.com/2020/09/17/wfULz6.png" alt="wfULz6">
<img src="https://s1.ax1x.com/2020/09/17/wfdWbF.png" alt="wfdWbF">
<img src="https://s1.ax1x.com/2020/09/17/wf0Dlq.png" alt="wf0Dlq"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1b7411N798">数据结构-王道</a>
<a href="https://408.kimyang.cn/DataStructure/">数据结构-王道笔记</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 笔记</title>
    <url>/2020/09/16/TypeScript/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p><a href="https://juejin.im/post/6872111128135073806">一份不可多得的 TS 学习指南</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<a id="more"></a>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>尖括号语法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&#x27;this is a string&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure>

<p>as 语法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&#x27;this is a string&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure>

<h2 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h2><p>unknown 类型只能被赋值给 any 类型和 unknown 类型本身</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value1: unknown = value; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> value2: <span class="built_in">any</span> = value; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> value3: <span class="built_in">boolean</span> = value; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value4: <span class="built_in">number</span> = value; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value5: <span class="built_in">string</span> = value; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value6: <span class="built_in">object</span> = value; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value7: <span class="built_in">any</span>[] = value; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value8: <span class="built_in">Function</span> = value; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>unknown 不能进行值操作</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown;</span><br><span class="line"></span><br><span class="line">value.foo.bar; <span class="comment">// Error</span></span><br><span class="line">value.trim(); <span class="comment">// Error</span></span><br><span class="line">value(); <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">new</span> value(); <span class="comment">// Error</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h2 id="接口-可选-amp-只读属性"><a href="#接口-可选-amp-只读属性" class="headerlink" title="接口 可选&amp;只读属性"></a>接口 可选&amp;只读属性</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<h2 id="接口-任意属性"><a href="#接口-任意属性" class="headerlink" title="接口 任意属性"></a>接口 任意属性</h2><p>有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 索引签名 的形式来满足上述要求。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = &#123; name: <span class="string">&#x27;semlinker&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> p2 = &#123; name: <span class="string">&#x27;lolo&#x27;</span>, age: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> p3 = &#123; name: <span class="string">&#x27;kakuqo&#x27;</span>, sex: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p>
<p>&lt;T&gt;中 T 代表 Type,是一种<strong>类型</strong>变量,它是我们希望传递给函数的<strong>类型占位符</strong></p>
<p>实际上 T 可以用任何有效名称代替。除了 T 之外，以下是常见泛型变量代表的意思：</p>
<ul>
<li>K（Key）：表示对象中的键类型；</li>
<li>V（Value）：表示对象中的值类型；</li>
<li>E（Element）：表示元素类型。</li>
</ul>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f1: GenericIdentityFn&lt;<span class="built_in">string</span>&gt; = <span class="function">(<span class="params">p1</span>) =&gt;</span> p1;</span><br><span class="line"><span class="built_in">console</span>.log(f1(<span class="string">&#x27;Hello&#x27;</span>)); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<h3 id="包含泛型方法的接口"><a href="#包含泛型方法的接口" class="headerlink" title="包含泛型方法的接口"></a>包含泛型方法的接口</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IncludeGenericObj &#123;</span><br><span class="line">    fn1: &lt;T&gt;<span class="function">(<span class="params">v1: T</span>) =&gt;</span> T;</span><br><span class="line">    p1?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f1: IncludeGenericObj = &#123;</span><br><span class="line">    fn1: <span class="function">(<span class="params">p1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(f1.fn1(<span class="number">1</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="CompilerOptions-选项"><a href="#CompilerOptions-选项" class="headerlink" title="CompilerOptions 选项"></a>CompilerOptions 选项</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">/* 基本选项 */</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>, <span class="comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span></span><br><span class="line">        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>, <span class="comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span></span><br><span class="line">        <span class="attr">&quot;lib&quot;</span>: [], <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">        <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">        <span class="attr">&quot;checkJs&quot;</span>: <span class="literal">true</span>, <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">        <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span>, <span class="comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class="line">        <span class="attr">&quot;declaration&quot;</span>: <span class="literal">true</span>, <span class="comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span></span><br><span class="line">        <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">true</span>, <span class="comment">// 生成相应的 &#x27;.map&#x27; 文件</span></span><br><span class="line">        <span class="attr">&quot;outFile&quot;</span>: <span class="string">&quot;./&quot;</span>, <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">        <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./&quot;</span>, <span class="comment">// 指定输出目录</span></span><br><span class="line">        <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./&quot;</span>, <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">        <span class="attr">&quot;removeComments&quot;</span>: <span class="literal">true</span>, <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">        <span class="attr">&quot;noEmit&quot;</span>: <span class="literal">true</span>, <span class="comment">// 不生成输出文件</span></span><br><span class="line">        <span class="attr">&quot;importHelpers&quot;</span>: <span class="literal">true</span>, <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">        <span class="attr">&quot;isolatedModules&quot;</span>: <span class="literal">true</span>, <span class="comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">        <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>, <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">        <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>, <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">        <span class="attr">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span>, <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">        <span class="attr">&quot;noImplicitThis&quot;</span>: <span class="literal">true</span>, <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">        <span class="attr">&quot;alwaysStrict&quot;</span>: <span class="literal">true</span>, <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 额外的检查 */</span></span><br><span class="line">        <span class="attr">&quot;noUnusedLocals&quot;</span>: <span class="literal">true</span>, <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">        <span class="attr">&quot;noUnusedParameters&quot;</span>: <span class="literal">true</span>, <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">        <span class="attr">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>, <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">        <span class="attr">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="literal">true</span>, <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">        <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>, <span class="comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>, <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">        <span class="attr">&quot;paths&quot;</span>: &#123;&#125;, <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">        <span class="attr">&quot;rootDirs&quot;</span>: [], <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">        <span class="attr">&quot;typeRoots&quot;</span>: [], <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">        <span class="attr">&quot;types&quot;</span>: [], <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">        <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Source Map Options */</span></span><br><span class="line">        <span class="attr">&quot;sourceRoot&quot;</span>: <span class="string">&quot;./&quot;</span>, <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">        <span class="attr">&quot;mapRoot&quot;</span>: <span class="string">&quot;./&quot;</span>, <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">        <span class="attr">&quot;inlineSourceMap&quot;</span>: <span class="literal">true</span>, <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">        <span class="attr">&quot;inlineSources&quot;</span>: <span class="literal">true</span>, <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 其他选项 */</span></span><br><span class="line">        <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>, <span class="comment">// 启用装饰器</span></span><br><span class="line">        <span class="attr">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span> <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>TypeScript</tag>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>真奇妙</title>
    <url>/2020/09/15/%E7%9C%9F%E5%A5%87%E5%A6%99/</url>
    <content><![CDATA[<h3 id="为什么抽烟会产生翔意"><a href="#为什么抽烟会产生翔意" class="headerlink" title="为什么抽烟会产生翔意"></a>为什么抽烟会产生翔意</h3><p>烟里面含有尼古丁，能够激动人体内的 N1,N2 受体，N1 受体被激动时表现为兴奋胃肠道平滑肌，膀胱平滑肌，心肌收缩力加强，血压升高。而胃肠道平滑肌兴奋就能让人加快排便，故而产生想拉屎的感觉，不进想拉屎，还想拉尿。</p>
<a id="more"></a>

<h3 id="为什么人运动后会发热"><a href="#为什么人运动后会发热" class="headerlink" title="为什么人运动后会发热"></a>为什么人运动后会发热</h3><p>运动时人体产热主要来自肌肉</p>
<p>肌细胞分解葡萄糖产生 ATP 来提供能量，但效率大概只有 40%（这个效率已经很高了），剩下的基本都以热量散发出来。</p>
<p>运动肌肉会产生不断收缩和舒张,收缩和舒张都要做功，这样就产生热量。运动也是消耗能量的，直接能量就是 ATP，肌蛋白上的微细结构横桥能利用 ATP 来消耗能量用于肌肉做功，做的功变成热能。</p>
<p>运动后身体的新陈代谢加强，伴随着能量消耗，产生大量的热量，肌肉运动摩擦也会产热，此时皮肤会大量出汗来散热，但相对较慢，所以身体就会发热，这是一种正常的生理现象。</p>
]]></content>
  </entry>
  <entry>
    <title>JS运行原理</title>
    <url>/2020/09/15/JS%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="JS-动态类型的特性"><a href="#JS-动态类型的特性" class="headerlink" title="JS 动态类型的特性"></a>JS 动态类型的特性</h2><p>动态类型语言在编码时提供的信息太少了,让编译器无法在运行前知道变量的类型,只有在运行期间才能确定各个变量的类型,这就导致 JS 无法在运行前编译出更加快速的低级语言的代码,也就是机器代码(Machine Code)</p>
<a id="more"></a>

<h2 id="事件循环-amp-异步回调"><a href="#事件循环-amp-异步回调" class="headerlink" title="事件循环 &amp; 异步回调"></a>事件循环 &amp; 异步回调</h2><p>JavaScript 的执行环节是一个单线程,也就意味着 JS 环境只有一个调用栈,如果调用栈中某个函数执行需要消耗大量时间,就会导致调用栈被阻塞,无法入栈和出栈</p>
<p>由于浏览器中页面的布局绘制和 JS 的执行是共用的同一个主线程,如果 JS 的处理迟迟不归还主线程的话,就会影响页面的渲染,导致页面卡顿</p>
<p>优化的方法就是使用事件循环 &amp; 异步回调</p>
<h2 id="JIT-amp-AOT"><a href="#JIT-amp-AOT" class="headerlink" title="JIT &amp; AOT"></a>JIT &amp; AOT</h2><p>Just In Time(JIT)在运行时生成机器代码,而不是提前生成.在运行阶段收集类型信息,然后根据信息编译机器码,之后再运行代码时直接使用机器码</p>
<p>Ahead Of Time(AOT)在运行前提前生成好机器码</p>
<h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><ol>
<li><p>引擎负责将高级语言 JS 转为低级语言机器码</p>
</li>
<li><p>JS 引擎首先将 JS 源码通过 parser(解析器)解析成抽象语法树(AST)</p>
</li>
<li><p>接着通过 interpreter(解释器)将 AST 编译成字节码(bytecode)</p>
</li>
<li><p>字节码通过 compiler(编译器)生成 machine code(机器码)</p>
</li>
</ol>
<div class="note no-icon">
            <p>字节码:是一种中间状态(中间码)的二进制代码(文件),这也是为什么 Java 这种语言可以跨平台的原因</p><p>机器码:是电脑 CPU 直接读取运行的机器指令,运行速度最快</p><p>不同平台的机器代码会有差异,所以编译器会根据当前平台(如 ARM x64)编译出不同平台的机器码,这里的机器码其实就是汇编代码</p>
          </div>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.bilibili.com/video/BV1vh411Z7QG">📹 JS 运行原理</a>
<a href="https://www.bilibili.com/video/BV1zV411z7RX">📹 V8 引擎如何运行</a>
<a href="https://www.bilibili.com/video/BV13k4y1y7vU">📹 JS 调用栈</a></p>
]]></content>
      <tags>
        <tag>Web前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 - Vue3</title>
    <url>/2020/09/13/Vue3/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Vue3 新特性! 就很棒! </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<a id="more"></a>

<ul>
<li>provide / inject</li>
<li>teleport</li>
<li>ref/reactive (两种方法都会使引用变为响应式的)<ul>
<li>ref: 由于原始类型(String,Number,Undefined,Null,Boolean)为值传递,不是引用传递,所以需要通过 ref 方法包裹原始类型,返回统一的对象属性, 通过 value 来访问</li>
<li>reactive 展开后不再为响应式 需要使用 toRefs 方法包裹</li>
</ul>
</li>
<li>watchEffect<ul>
<li>watchEffect 中有使用到的值发生变化时,watchEffect 方法将被调用</li>
<li>可以定义多个 watchEffect 方法,分别处理不同的逻辑</li>
<li>watchEffect 返回一个方法 调用可停止 watchEffect</li>
</ul>
</li>
<li>Composition Api<ul>
<li>超大项目时使用</li>
<li>在 setup 中定义<ul>
<li>setup 方法在组件创建前执行,所以没有 this 属性,不能访问 prop,computed,mothod (可以访问 prop, attr, slots, emit)</li>
<li>接受参数 props 和 context<ul>
<li>props 就是 props 属性的引用</li>
<li>context 对象暴露组件属性 context.attrs, context.emit, context.slots<ul>
<li>context 非响应式属性,所以可以使用结构写法 setup(props, { attrs, slots, emit }) { … }</li>
</ul>
</li>
</ul>
</li>
<li>setup 的返回值将暴露给组件的其他部分(计算属性,方法,声明周期,模板组件等等)</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Vue3</tag>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo 😘</title>
    <url>/2020/09/13/Hexo/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<a id="more"></a>

<h2 id="博客地址"><a href="#博客地址" class="headerlink" title="博客地址"></a>博客地址</h2><p><a href="https://nxir.github.io/">Github 链接</a>(国内速度慢)</p>
<p><a href="https://coding-pages-bucket-3473968-7947127-539-310661-1303164992.cos-website.ap-hongkong.myqcloud.com/">Coding 链接</a>(速度快,需要自定义域名)</p>
<p><a href="https://nxir.gitee.io/">Gitee(码云)链接</a>(速度快,非会员不支持自动部署更新)</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo.io/zh-cn/">中文官网</a></p>
<p><a href="https://www.bilibili.com/video/BV1dt4y1Q7UE">快速搭建并自动化部署到 Github</a></p>
<p><a href="https://github.com/search?o=desc&p=1&q=hexo-theme&s=stars&type=Repositories">Github 上的 Hexo 主题</a></p>
<p>推荐主题 <a href="https://theme-next.js.org/">Next</a></p>
<p><a href="https://www.jianshu.com/p/3fe88ef479dd">Next 添加菜单页面</a></p>
<p><a href="https://valine.js.org/">使用 Valine 接入评论</a></p>
<p><a href="https://github.com/cwxyz007/vscode-hexo-utils">vscode-hexo-utils</a></p>
<p><a href="https://juejin.im/post/6844904144013099022">部署到码云和 Coding</a></p>
<blockquote>
<p>coding 需要实名认证,自定义域名</p>
</blockquote>
<blockquote>
<p>码云需要每次提交后手动部署更新 Gitee Page</p>
</blockquote>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
